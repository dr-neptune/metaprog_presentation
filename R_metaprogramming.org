:PROPERTIES:
:header-args: :session R-session :results output raw
:END:

#+BEGIN_SRC R
library(rlang)
library(tidyverse)
library(magrittr)
library(pipeR)

## this function gets the arguments passed to a function
get_args <- function() {
    as.list(match.call(
        def = sys.function(-1),
        call = sys.call(-1)))[-1]
}
#+END_SRC

* A Spoonful of Metaprogramming
  (is good for what ails you)

* What?

A language that supports metaprogramming is a language that supports programming itself. This could mean many things, but here we are going to focus on 2 aspects:
** Code is data, data is code
** The programming language itself is programmable

* Manipulating Functions

  There are 3 parts of a function in R:

#+BEGIN_SRC R
f <- function(x) x + 25

## formals
formals(f)

## body
body(f)

## environment
environment(f)
#+END_SRC

** Formals

   Formals are a list, so we can treat it as such:

#+BEGIN_SRC R
## define multi-parameter function
(g <- function(x, y, z) (x + y) / z)

g(1, 2, 3)

## look at formals
formals(g)

## mess with it
rev_forms <- function(fun) {
    formals(fun) <- rev(formals(fun))
    fun
}

(g <- rev_forms(g))

g(1, 2, 3)

## make it more interesting : add some variables
formals(g) %<>% append(list("a" = missing_arg(),
                         "b" = missing_arg(),
                         "c" = missing_arg()))

g

## add global scope variables
w <- runif(1)

formals(g)$c <- w

g
#+END_SRC

It is worth noting here, that when you pass a function an argument, it is technically a data structure called a promise. This means that it is not evaluated as soon as it is receieved. This will be important later.

** Body

   The function body is an expression

#+BEGIN_SRC R
## look at body
body(g)

## see how the data structure is put together
body(g) %>% as.character

body(g)[[1]]
body(g)[[2]]
body(g)[[3]]

## modify it
body(g)[[3]] <- quote(z + a + b + c)
body(g)

## evaluate our new expression
g(1, 2, 3)

## let c be evaluated by w
g(1, 2, 3, 4, 5)

## let c = 6
g(1, 2, 3, 4, 5, 6)

## check that it matches!
(3 + 2) / (1 + 4 + 5 + 6)
#+END_SRC

We can even have a function find its own definition:

#+BEGIN_SRC R
f <- function(x = 5) {
    y <- x + 10
    sys.function()
}

f()

body(f)

body(f)[[2]] <- body(f)

body(f)

f()

f <- function(x = 5) {
    if (x == 0) sys.function()
    else {
        body(f)[[3]] <- body(f)
        f(x - 1)
    }
}

f(10)
#+END_SRC

** Environments

   Environments are the scope in which the function is evaluated
   
#+BEGIN_SRC R
environment()

h <- function() {
    environment()
}

h()

## get parent environment
parent.env(h())

## these can be manipulated like lists, but they are really more like a hash table without collisions
new_env <- new.env()
new_env$x <- 1
new_env$x

## we can loop through and assign
map2(state.abb, 1:50, ~ {new_env[[.x]] <- .y})

## access each value by name
new_env$MA

## and get values as needed
new_env %>% names()
#+END_SRC

* Manipulating Expressions

We can capture code without evaluating it using expr()

#+BEGIN_SRC R
x <- 2
y <- 0

## quote!
(z <- expr(y <- x * x * x * x * x))

## unquote
eval(z)

y

## we can also selectively quote subexpressions
(z <- bquote(y <- .(x) + 256))

y

eval(z)

y
#+END_SRC

What was done above is called quotation (the act of capturing an unevaluated expression) and unquotation (the ability to evaluate parts of an otherwise quoted expression). Together, this is referred to as *Quasiquotation*. 

This is all over the place in R

#+BEGIN_SRC R
## ever wonder why we can write this
mtcars %>%
    filter(qsec > 20)

## and not this?
mtcars %>% filter(.[["qsec"]] > 20)

## or this?
mtcars %>% filter(mtcars$qsec > 20) 

## especially since
qsec
#+END_SRC

Under the hood, we are taking the expression, and waiting to evaluate it until we have the proper environment to evaluate it in. In this case, our awaited environment is the dataset mtcars.

This is an example of tidy evaluation. It combines quasiquotation, quosures (a data structure that captures an expression and its environment), and data masks (which allow an expression to be evaluated in the context of its dataset).

* TidyEval

Tidyeval is very practical, as it lets you use functions without quotes all over the place as well as reference things in different scopes and data masks. It helps match expressions to environments. It helps create a more interactive workflow at the expense of having to know a bunch more things when writing functions.

Pragmatically, you can use it to write functions that act on nested data (i.e., data in dataframes)

#+BEGIN_SRC R
## if you're only doing 1 thing, you can use {{}}
tally_it <- function(.data, column) {
    .data %>% 
        group_by({{column}}) %>%
        tally(sort = TRUE)
}

mtcars %>% tally_it(mpg)
mtcars %>% tally_it(mpg, hp)

## you can use ... parsing and expansion for multiple args
tally_it <- function(.data, ...) {
    (args <- enexprs(...))
    
    .data %>%
        group_by(!!!args) %>%
        tally(sort = TRUE)
}

mtcars %>% tally_it(mpg, hp, disp)

## you can even coerce strings to exprs beforehand
tally_it <- function(.data, ...) {
    args <- enexprs(...)

    if (is.character(pluck(args, 1)))
        args <- map(args, parse_expr)
    
    .data %>%
        group_by(!!!args) %>%
        tally(sort = TRUE)
}

mtcars %>% tally_it("mpg", "hp", "disp")

## plots
plot_it <- function(.data, x, y) {
    ## get arguments and coerce to character
    xlab <- as.character(get_args()$x)
    ylab <- as.character(get_args()$y)

    .data %>%
        ggplot(aes(x = {{x}}, y = {{y}})) +
        geom_point() +
        ggtitle(paste0(ylab, " ~ ", xlab))
}

mtcars %>% plot_it(mpg, disp)
#+END_SRC

* Substitutions

  This is useful because we can do similar substitutions

#+BEGIN_SRC R
## we can coerce exprs to strings and manipulate them
expr(y <- x + x + x + x + z) %>%
    deparse() %>%
    str_glue(" + z + z + z") %>%
    parse_expr() -> new_expression

x <- 2
y <- 0
z <- 1

eval(new_expression)

y
#+END_SRC

This idea means we can now make code 'data'

#+BEGIN_SRC R
mtcars %<>% 
    ## get car names
    as_tibble(rownames = "car_names")

## generate a bunch of statements
mtcars %>%
    pull(1) %>%
    ## get just makes
    str_extract("^[A-Za-z]+") %>%
    unique() %>>%
    ## set names
    (~ unique_names) %>%
    ## 'build' out a string
    map(~ .x %>% paste0("\"", ., "\" = ifelse(str_detect(car_names, \"", ., "\"), TRUE, FALSE)") %>% parse_expr()) %>%
    set_names(unique_names) -> conditional_statements

mtcars %>%
    mutate(!!!conditional_statements) %>% glimpse
#+END_SRC

We can *quote* data, and the *unquote* it to make code

We can do more with this by writing code that changes R code. In other languages, these are often called *macros*. 

#+BEGIN_SRC R
## in R we often chain together pipelines like so
mtcars %>%
    select(mpg, cyl, disp, hp) %>%
    filter(cyl == 6) %>%
    summarize(mean(mpg))

## this translates to the following
summarize(filter(select(mtcars, mpg, cyl, disp, hp), cyl == 6), mean(mpg))
#+END_SRC

The pipe is an example of an infix operator. It takes arguments on both sides, and translates the code to a properly written function call. We can write our own:

#+BEGIN_SRC R
`%r%` <- function(expr, num) replicate(num, expr)

## now we can use this like we would any other infix operator
rexp(1) %r% 3
rexp(3) %r% 3
rexp(3) %r% 3 %r% 4
#+END_SRC

** An example : Replicating Clojure Threading Macros

While the pipe is fantastic, it does replicate %>% over and over again at the end of each line. This is not that bad if you have a key-binding

In clojure, they use prefix notation:

#+BEGIN_SRC clojure
(-> (load-data "xyz.csv")
    (i/$ "those_columns")
    (i/filter {:cyl {:eq 6}})
    (i/mean :mpg))
#+END_SRC

We can create something similar in R (minus all those parentheses):

#+BEGIN_SRC R
p_ <- function(f_1, ...) {
    ## take in all our arguments as quoted expressions
    enexprs(f_1, ...) %>%
        ## deparse them to turn them into strings! paste the pipe
        map_chr(~ deparse(.x) %>% str_glue(" %>% ")) %>%
        ## collapse to one string
        paste(collapse = "") %>%
        ## add identity to the end (lazy hack)
        str_glue("identity") %>%
        ## parse the string back to a quoted expression
        parse(text = .) %>%
        ## evaluate it!
        eval()
}

plus_n <- function(n) function(x) x + n

x <- 1

p_(x,
   plus_n(3)(),
   plus_n(2)(),
   plus_n(3)())

p_(mtcars,
   select(mpg, cyl, disp, hp),
   filter(cyl == 6),
   summarize(mean(mpg)))
#+END_SRC

Of course here all we did was replace %>% with ,

**The big idea is that we are not delegated to writing code according to the whims of the language designer, but we are the language designer**

Here are some other examples of me using this:

- show peril explorer code
- show salesforce matching code

* Generating Code with R

  It doesn't even need to be R code we can generate. We can use R's flexibility to create other types of code as well. A great example is *dbplyr*, which translates R dplyr code to SQL.

#+BEGIN_SRC R
library(dbplyr)

## show a simple translation to sql

## mtcars %>%
##     simulate_
#+END_SRC

  Another great example is shiny, which generates html / css / javascript.

#+BEGIN_SRC R
## show shiny ui functions
#+END_SRC

This mainly just hinges on returning built up strings as the result of functions.
Show sql output of peril explorer
  
* Example
